<html>
<head>
<title> CS585 Homework Template: HW4 Alex Wong  </title>
<style>
<!--
body{
font-family: 'Trebuchet MS', Verdana;
}
p{
font-family: 'Trebuchet MS', Times;
margin: 10px 10px 15px 20px;
}
h4{
    margin: 15px;
}
h3{
margin: 10px;
}
h2{
margin: 10px;
}
h1{
margin: 10px 0px 0px 20px;
}
div.main-body{
align:center;
margin: 30px;
}
hr{
margin:20px 0px 20px 0px;
}
.img-face{
width:50%
}
.tg {
    border-collapse: collapse;
    border-spacing: 0;
}

.tg td {
    font-family: Arial, sans-serif;
    font-size: 14px;
    padding: 10px 5px;
    border-style: solid;
    border-width: 1px;
    overflow: hidden;
    word-break: normal;
    border-color: black;
}

.tg th {
    font-family: Arial, sans-serif;
    font-size: 14px;
    font-weight: normal;
    padding: 10px 5px;
    border-style: solid;
    border-width: 1px;
    overflow: hidden;
    word-break: normal;
    border-color: black;
}

.tg .tg-ted4 {
    border-color: #333333;
    text-align: center;
    vertical-align: middle;
}

-->
</style>
</head>

<body>
<center>
<a href="http://www.bu.edu"><img border="0" src="http://www.cs.bu.edu/fac/betke/images/bu-logo.gif"
width="119" height="120"></a>
</center>

<h1>Assignment 4</h1>
<p> 
CS 585 HW 4<br>
Alex Wong, Wei-Hsiang Lin and Rahul Suresh Babu<br>
March 24, 2020
</p>

<h1>Part 1</h1>
<div class="main-body">

<hr>
<h2>Problem Definition</h2>
<!-- TODO(R) -->
<p>The current problem involves the implementation of tracking algorithms. 
Specifically two datasets have been given, the bat dataset and the cell dataset. 
Multiple objects are present in each frame and have to be tracked. 
The assumptions we make are that the objects move only slightly between two frames. 
The anticipated difficulties are implementing a reliable tracking algorithm and obtaining correct segmentation data.</p>

<hr>
<h2>Method and Implementation </h2>
<h3>Multiple Object Tracking</h3>
<h4>Alpha-Beta Filtering</h4>
<!--TODO(R) - Implement an alpha-beta filter or using a third-party Kalman filter library and get good tracking results for simple situations (e.g. when objects move separately without occluding each other)-->
<p>For the tracking part, an alpha-beta tracker was implemented. The alpha beta observer is a simplified form of a linear state observer that assumes an object can be described by a model with 2 internal states. This system accounts for both process noise and measurement noise and is a lower order approximation.

The two internal states represented by the model are <b>position and velocity</b>. This tracker has a prediction phase where it predicts the position and velocity for this time step using knowledge from the previous time step. In then calculates the residual ( measurement for this time step - prediction) and uses it to update the position and the velocity weighed by the parameters  α,β  respectively.
</p>
<img src="./img/summary.png" class="img-face"/>
<p>Figure 1 : Algorithm summary</p>

<p>For our implementation the equations used were,
</p>
<img src="./img/equations.png" class="img-face"/>
<p>Figure 2 : Update equations</p>
<p>The values for α,β itself are hyperparameters. Typically, lower values of  α,β  reflect more belief on the prediction ( when there is more measurement noise ) and higher values reflect more belief on the measurement (less measurement noise).</p>

<p>All this was the alpha beta tracker for a single object. While extending to multiple objects, the main problem was data association. Also, all of the above parameters had to re-written as matrices and vectors. So all the update operations became vector operations.</p>

<!-- <p>We implemented the greedy matching algorithm where older objects with longer tracking history were matched first. The gating used was a circular gate of 50 px. This was a trade off between recall and precision.</p>
 -->
<!-- <p>The code was highly modularized and separate classes were created to perform the main tasks. The data_loader class was created to load all images, localization and segmentation maps. Different flags were provided to control what to load.</p>
 -->
<!-- <p>The bat_tracking class performed the actual bat tracking.</p>
 -->

<ul>
    <li>show_frame_wise methods(): ran the tracking. Different other helper functions were created to perform the other tasks.
    </li>
    <li>create_color_hash(): create the color hash to plot the tracks of the different bats.</li>
    <li>draw_line(): drew the bat tracks on the image.</li>
    <li>update_velocity(): performed the velocity updates.</li>
    <li>update_coords(): performed the position updates</li>
    <li>subtract(): calculate the residual vector</li>
    <li>association(): performed the data association</li>
    <li>distance(): calculated the euclidean distance between two points</li>
    <li>get_x_pred(): predicted the object coordinates of the next time step.</li>
</ul>

<h4>Suboptimal Bipartite Matching Algorithm - Improving Greedy Algorithm</h4>
<!-- TODO(R) - Implement a greedy, suboptimal bipartite matching algorithm -->
<p>
    To solve the bipartite matching problem, we initially implemented greedy algorithm to solve it. However, the results were very bad; mostly because it is 'greedy'. As a result, we modified the greedy algorithm to gain better results. I will explain our modifications below:
</p>

<p>
    The traditional bipartite matching problem is - <b>how can we match 2 sets of data together?</b>; in this case, the group of localization points at each frame and the group of objects that are already recognized. Using the greedy algorithm, older objects wiht longer tracking history were matched first. The gating used was a circular gate of 50 px. This was a trade off between recall and precision.
</p>

<p>
    The first main problem with the greedy algorithm was most bats (and cells) stay from the first frame onwards, and therefore, there were many objects that had the longest tracking history possible. As a result, the greedy algorithm was not effective in this bat (and cell) dataset. 
</p>

<p>
    The second main problem is that greedy algorithm tries to match the localization points and objects in a 'greedy' manner. This is very not effective in a bipartite matching algorithm because there might be better matches along the way, but it not looked at yet (because it is greedy). 
</p>

<p>
    To address the two problems above, we implemented a slightly different version of it. First, every localization point picks the closest (as in predicted position) object. As you can imagine, it's possible for 2 localization points to pick the same object. In that case, we enforce a 1 to 1 mapping by keeping only the pair of localization point and object with closest distance. The rest of the points are now turned into "zombies". Zombies are converted into new objects. 
</p>

<h4>Handle localization errors - Half Dead</h4>

<p>
    Basically, this part tries the fix a problem where the localization points are not very consistent. There might be a frame or two where the bat is there, but the localization point for it is not picked up. This is the case in the original localization dataset provided to us. We aim to fix this problem using a concept we term "Half Dead". 
</p>

<p>
    Half Dead are unmatched objects by the end of the association method. They are 'half dead' because we don't want to discard them yet. We want to see if we can match them in the next n frames. n is a tunable variable; currently set to 2.
</p>

<h3>Segmentation/Localization</h3>
<h4>Cell Dataset</h4>
<!-- TODO(S) 
 - For cell dataset, implement a segmentation or detection algorithm to locate each cell.
 - Bonus: 1) detecting the birth of a new cell. 2) detecting migrating cells (i.e cells with filopodia). 3) handling the spurious detections (false positives). 4)trying different kinematic models. 
 - What are the advantages and drawbacks of different kinematic models: Do you need to model the velocity of the objects, or is it sufficient to just consider the distances between the objects in subsequent frames?
-->
<p>>>Type Here<<</p>

<hr>
<h2>Experiments</h2>
<!-- TODO(All) -->
<p>>>Type Here<<</p>

<hr>
<h2>Results</h2>
<!-- TODO(A) 
Display the results of your tracking algorithm on top of the original images. Use different colors to show that you successfully maintain track identity. Draw lines to show the history of the flight trajectories.
Show your tracking results on some portion of the sequence. In addition to showing your tracking results on an easy portion of the data, identify a challenging situation where your tracker succeeds, and a challenging situation where your tracker fails.
-->
<!--TODO(A)
    - Display the tracking results on top of the original images. Use different colors to show that you successfully maintain track identity. Draw lines to show the history of the flight trajectories
    - Challenge 1: Proper handling of situations when objects touch and occlude each other
    - Challenge 2: Proper handling of the beginning of new tracks and the termination of old tracks as the objects enter and leave the field of view
How do you decide to begin new tracks and terminate old tracks as the objects enter and leave the field of view?
What happens with your algorithm when objects touch and occlude each other, and how could you handle this so you do not break track?
What happens when there are spurious detections that do not connect with other measurements in subsequent frames?
-->


<p>>>Type Here<<</p>

<!-- <table>
    <tr>
        <th>Open Hand</th>
        <th>Open Hand Partial</th>
        <th>Open Fist</th>
        <th>Tumor</th>
    </tr>
    <tr>
        <td style="width:25%"><img src="./img/p1/open-bw-full.png" class="img-face"/></td>
        <td style="width:25%"><img src="./img/p1/open-bw-partial.png" class="img-face"/></td>
        <td style="width:25%"><img src="./img/p1/open_fist-bw.png" class="img-face"/></td>
        <td style="width:25%"><img src="./img/p1/tumor-fold.png" class="img-face"/></td>
    </tr>
</table> -->

<hr>
<h2> Discussion</h2>

<h3>Improving Greedy Algorithm</h3>
<p>As explained in the "Suboptimal Bipartite Matching Algorithm" section, we found the greedy algorithm to be ineffective for the bat and cell dataset. And as a result, we improved and implemented our own algorithm to solve the bipartite problem. The details are in the "Suboptimal Bipartite Matching Algorithm" section.</p>

<h3>Handle localization problems</h3>
<p>As explained in the "Handle localization errors" section above, the localization dataset might not be perfect and for a given object, the localization point of that object might be missing in some frames. We take in account of that in our algorithm. More details are explained in that section.</p>


<!-- TODO(S) -->
<p>>>Type Here<<</p>

<hr>
<h2> Conclusion</h2>
<!-- TODO(S) -->
<p>Future work would definitely include using kalman filters and the optimal matching (hungarian) algorithm. MHT could also be tried.</p>

<hr>
<h2> Credits and Bibliography </h2>
<!-- TODO(S) -->
<p>>>Type Here<<</p>

</div>
</body>
</html>

